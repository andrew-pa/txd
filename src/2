extern crate winapi;
extern crate kernel32;

use winapi::*;
use kernel32::*;
use std::char::decode_utf16;

struct Window { 
    out: HANDLE,
    cin: HANDLE
}

#[derive(Debug)]
enum Input {
    Unknown,
    KeyChar(char),
    KeyEscape,
    KeyFunc(i8)
}

impl Input {
    fn from_win32(inp: INPUT_RECORD) -> Input {
        match inp.EventType {
            KEY_EVENT => {
                let ker = unsafe { inp.KeyEvent() };
                match ker.wVirtualKeyCode as i32 {
                    VK_ESCAPE => Input::KeyEscape,
                    VK_F1 => Input::KeyFunc(1),
                    _=> { 
                        let v = &[ker.UnicodeChar];
                        let mut dv = decode_utf16(v.iter().cloned());
                        Input::KeyChar(dv.next().unwrap().unwrap())
                    }
                }
            },
            _ => Input::Unknown
        }
    }
}

struct InputQueue<'a> {
    win: &'a Window,
    queue: Vec<Input>
}

impl Window {
    fn new() -> Window {
        unsafe {
            let mut out = GetStdHandle(STD_OUTPUT_HANDLE); 
            let mut cin = GetStdHandle(STD_INPUT_HANDLE); 
            let mut mode: DWORD = 0;
            GetConsoleMode(out, &mut mode);
            SetConsoleMode(out, mode | 0x0004);
            Window { out: out, cin: cin }
        }
    }
    
    fn clear(&self) {
        print!("\x1b[2J");
    }

    fn set_cur(&self, x: usize, y: usize) {
        print!("\x1b[{},{}f", y, x);
    }

    fn write_char(&self, x: usize, y: usize, v: char) {
        let ch = [0u16, 2];
        v.encode_utf16(&mut ch);
        let mut numch: DWORD = 0;
        WriteConsoleOutputCharacterW(self.out, ch.as_mut_ptr(), ch.len() as u32, &mut numch); 
        assert!(numch == ch.len() as u32);
    }

    fn inputs(&self) -> InputQueue {
        InputQueue {win: self, queue: Vec::new()}
    }
}

impl<'a> Iterator for InputQueue<'a> {
    type Item = Input;

    fn next(&mut self) -> Option<Input> {
        if self.queue.is_empty() {
            let new_records = &mut [INPUT_RECORD{EventType: 0, Event:[0,0,0,0]}; 128];
            let mut num_rec: DWORD = 0;
            unsafe {
                ReadConsoleInputW(self.win.cin, new_records.as_mut_ptr(), new_records.len() as u32, &mut num_rec);
            }
            for i in 0..num_rec {
                self.queue.push(Input::from_win32(new_records[i as usize]));
            }
            self.queue.pop()
        } else {
            self.queue.pop()
        }
    }
}

fn main() {
    let mut win = Window::new(); 
    win.clear();
    win.set_cur(0,0);
    println!("\x1b[92mHello, world!\x1b[0m");
    'mainloop: loop {
        for i in win.inputs() {
            match i {
                Input::KeyFunc(1) => break 'mainloop,
                Input::KeyChar(c) => win.write_char(0,0,c),
                _ => print!("\x1b[42m{:?}\x1b[0m", i)
            }
        }
        win.set_cur(0,0);
    }
}
